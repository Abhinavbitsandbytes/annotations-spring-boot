@SpringBootApplication

This is not magic. It‚Äôs a convenience annotation that bundles three critical annotations.
If you don‚Äôt know what those three do individually, you don‚Äôt understand Spring Boot.

@SpringBootApplication = meta-annotation

It is equivalent to writing all three below on your main class:

@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan

1. @SpringBootConfiguration

Same as @Configuration
Marks the class as a source of bean definitions
Tells Spring: ‚ÄúThis class can define beans‚Äù
üëâ Without this, Spring doesn‚Äôt treat your app as a configuration source.

2. @EnableAutoConfiguration

Heart of Spring Boot
Automatically configures beans based on classpath
Example:
spring-webmvc present ‚Üí configures DispatcherServlet
spring-data-jpa present ‚Üí configures EntityManagerFactory
üëâ This is what eliminates XML and boilerplate.

3. @ComponentScan

Scans for:
@Component
@Service
@Repository
@Controller

Default scan package = package of the main class + subpackages
üëâ Misplacing your main class = app breaks silently.

@SpringBootApplication
public class MyApplication {

    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}

Q1: What does @SpringBootApplication do internally?
‚úÖ Correct answer:

It is a meta-annotation that combines @SpringBootConfiguration, @EnableAutoConfiguration, and @ComponentScan.

Q2: Can we replace @SpringBootApplication?
‚úÖ Yes. Use the three annotations manually.

Q3: How does Spring Boot know what to auto-configure?
‚úÖ Based on:

->Classpath dependencies
->spring.factories / AutoConfiguration.imports


->Conditional annotations like:

    ->@ConditionalOnClass
    ->@ConditionalOnMissingBean

Q4: Where should the main class be placed?
‚úÖ At the root package of the project.
Bad answer = ‚Äúanywhere‚Äù

4Ô∏è‚É£ Common Catches & Confusions (pay attention)
‚ùå Confusion 1: ‚ÄúIt enables component scanning everywhere‚Äù
Wrong.
üëâ It scans only from the package of the main class downward.
com.example.app   ‚Üê main class here
  ‚îú‚îÄ‚îÄ controller  ‚úÖ scanned
  ‚îú‚îÄ‚îÄ service     ‚úÖ scanned
  ‚îî‚îÄ‚îÄ util        ‚úÖ scanned

If your controller is in com.other.controller ‚Üí NOT scanned

‚ùå Confusion 2: ‚ÄúSpring Boot auto-configures everything‚Äù
Wrong.
It auto-configures only if:
Dependency exists
No conflicting bean already defined
Conditions pass

Example:
@Bean
public DataSource dataSource() { ... }

üëâ Auto-configured DataSource is disabled

‚ùå Confusion 3: ‚Äú@SpringBootApplication is mandatory‚Äù
Wrong.
You can build Spring apps without it.
It just saves typing and configuration.

‚ùå Confusion 4: Multiple @SpringBootApplication
Terrible idea.
Only one main configuration class should exist.
Multiple = unpredictable component scanning.

5Ô∏è‚É£ Notes-Friendly Summary (write this down)
@SpringBootApplication
= @SpringBootConfiguration
+ @EnableAutoConfiguration
+ @ComponentScan

Purpose:
- Entry point for Spring Boot app
- Enables auto-configuration
- Starts component scanning
- Defines configuration source

Default behavior:
- Scans current package + subpackages
- Auto-configures beans based on classpath

Key rule:
- Place main class at root package


------------------------------------------------------

@Configuration

1Ô∏è‚É£ Theory (what it really does)

@Configuration marks a class as a Spring configuration class ‚Äî a class that defines beans using @Bean methods.

But the important part most people miss:

@Configuration classes are CGLIB-proxied to enforce singleton behavior.

This is not optional trivia ‚Äî this is the whole point.

What Spring does internally

When Spring sees:

@Configuration
public class AppConfig {
}


It:

Treats this class as a source of bean definitions
Creates a proxy subclass of it using CGLIB
Intercepts calls to @Bean methods

Why?
üëâ To ensure one and only one bean instance per container.

2Ô∏è‚É£ Code Snippet (correct + revealing)
Basic usage
@Configuration
public class AppConfig {

    @Bean
    public UserService userService() {
        return new UserService();
    }
}


This registers userService as a Spring bean.

The part people mess up (VERY IMPORTANT)
@Configuration
public class AppConfig {

    @Bean
    public Engine engine() {
        return new Engine();
    }

    @Bean
    public Car car() {
        return new Car(engine());
    }
}

What actually happens?

engine() is called once

Same Engine instance is injected into Car

Why?
Because Spring intercepts the method call using a proxy.

3Ô∏è‚É£ Interview Perspective (expected answers)
Q1: Difference between @Configuration and @Component?

‚úÖ Correct answer:

Feature	@Configuration	@Component
Bean methods	Yes (@Bean)	Yes
Proxying	Yes (CGLIB)	‚ùå No
Singleton guarantee	Yes	‚ùå No
Intended use	Config class	Generic bean

If they ask ‚Äúwhy proxying?‚Äù
Say: To preserve singleton semantics of @Bean methods

Q2: What happens if you remove @Configuration?
@Component
public class AppConfig {


üëâ Each call to engine() creates a new instance
üëâ You silently break singleton behavior

This is a classic senior-level trap question.

Q3: Is @Configuration mandatory?

‚ùå No.

But without it:

No proxying

No inter-bean lifecycle management

4Ô∏è‚É£ Common Catches & Confusions (read twice)
‚ùå Confusion 1: "@Configuration is same as @Component"

Wrong.

@Configuration = specialized @Component
with proxy-based behavior.

‚ùå Confusion 2: Calling @Bean methods directly is safe

Only safe inside a @Configuration class.

Outside:

new AppConfig().engine(); // NOT managed by Spring


üëâ Completely bypasses Spring.

‚ùå Confusion 3: Final classes or methods
@Configuration
public final class AppConfig { ‚ùå }

or

@Bean
public final Engine engine() { ‚ùå }


‚ùå CGLIB cannot proxy final
üëâ Spring will either fail or downgrade behavior

‚ùå Confusion 4: Performance concerns

Yes, proxying has overhead ‚Äî but:

Happens at startup

Negligible vs application lifecycle

If someone avoids @Configuration for ‚Äúperformance‚Äù, they don‚Äôt know what they‚Äôre doing.

5Ô∏è‚É£ Notes-Friendly Summary (copy-paste)
@Configuration
- Marks class as source of bean definitions
- Uses CGLIB proxy
- Ensures singleton behavior of @Bean methods
- Intercepts inter-bean method calls

Key point:
@Configuration ‚â† @Component

Without @Configuration:
- No proxying
- New instance per @Bean call

-------------------------------------------------------------

@Bean
1Ô∏è‚É£ Theory (what @Bean ACTUALLY does)

@Bean tells Spring:

‚ÄúThe object returned by this method should be managed by the Spring container.‚Äù

That‚Äôs it.
No magic. No scanning. Explicit bean registration.

Key truth (write this down)

@Component ‚Üí implicit bean creation (via scanning)

@Bean ‚Üí explicit bean creation (via method call)

Spring does not create the object.
YOU create it, Spring just manages the lifecycle.

Where @Bean is allowed

@Bean must be inside:

    @Configuration (preferred)
    or any @Component (works, but with consequences)

2Ô∏è‚É£ Code Snippets (correct + traps)
Basic usage

@Configuration
public class AppConfig {

    @Bean
    public EmailService emailService() {
        return new EmailService();
    }
}


Result:

    Bean name ‚Üí emailService
    Scope ‚Üí singleton (default)
    Managed by Spring

Dependency injection via method calls (IMPORTANT)
@Configuration
public class AppConfig {

    @Bean
    public Engine engine() {
        return new Engine();
    }

    @Bean
    public Car car() {
        return new Car(engine());
    }
}


üëâ Even though engine() is called inside car()
üëâ Same singleton instance is used

WHY?
Because @Configuration uses CGLIB proxying (you learned this already).

‚ùå Classic mistake: using @Bean inside @Component
@Component
public class AppConfig {

    @Bean
    public Engine engine() {
        return new Engine();
    }

    @Bean
    public Car car() {
        return new Car(engine());
    }
}


‚ùå Result:

engine() called twice
Two different Engine objects
Singleton contract broken silently
This is a real production bug, not theory.

3Ô∏è‚É£ Interview Perspective (expected answers)
Q1: Difference between @Bean and @Component?

‚úÖ Correct answer:

Aspect	@Bean	@Component
Registration	Explicit	Implicit
Location	Method	Class
Use case	Third-party / fine control	App-level components
Creation	Developer creates object	Spring creates object

Q2: When should you prefer @Bean?

‚úÖ Use @Bean when:

You don‚Äôt own the class (third-party libs)

You need custom construction logic

Object creation is conditional or complex

Example:

@Bean
public ObjectMapper objectMapper() {
    return JsonMapper.builder()
        .enable(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)
        .build();
}

Q3: What is the default scope of @Bean?

‚úÖ singleton

If they ask how to change it:

@Bean
@Scope("prototype")
public Engine engine() {
    return new Engine();
}

Q4: How does Spring resolve dependencies for @Bean methods?

Answer:

By method calls (inside @Configuration)

Or by method parameters (preferred)

@Bean
public Car car(Engine engine) {
    return new Car(engine);
}


This is cleaner and safer.

4Ô∏è‚É£ Common Catches & Confusions (THIS IS GOLD)
‚ùå Confusion 1: Bean name confusion
@Bean
public Engine myEngine() { ... }


Bean name = myEngine

If you do:

@Bean(name = "engine")
public Engine myEngine() { ... }


Bean name = engine

Injection will fail if names mismatch.

‚ùå Confusion 2: Multiple beans of same type
@Bean
public Engine petrolEngine() {}

@Bean
public Engine dieselEngine() {}


‚ùå Autowiring by type fails.

Fix using:

@Qualifier

or @Primary

‚ùå Confusion 3: Calling @Bean method manually
Engine e = appConfig.engine(); ‚ùå


This bypasses Spring unless proxied.
Outside container = unmanaged object.

‚ùå Confusion 4: @Bean ‚â† lazy by default

@Bean methods are eagerly executed at startup.

To make lazy:

@Bean
@Lazy
public Engine engine() { ... }

5Ô∏è‚É£ Notes-Friendly Summary (copy exactly)
@Bean
- Explicitly registers a bean
- Method return value becomes Spring-managed
- Default scope = singleton
- Bean name = method name
- Best used inside @Configuration

Key rule:
@Bean inside @Component breaks singleton guarantees

Brutally Honest Reality Check

If you:

Put @Bean inside random @Components

Call @Bean methods manually

Don‚Äôt understand proxying

Then your app works by accident, not by design.

Senior Spring devs avoid accidental behavior.


-------------------------------------------------------------

@Component
1Ô∏è‚É£ Theory (what @Component really means)

@Component tells Spring:

‚ÄúThis class is a candidate for component scanning and should be managed as a bean.‚Äù

That‚Äôs it.

No lifecycle magic.
No special behavior.
No auto-transaction.
No proxying by default.

It‚Äôs just a generic Spring-managed bean.

How @Component works internally

Detected only via @ComponentScan

Registered as a bean in the ApplicationContext

Instantiated by Spring

Dependency injection happens afterward

If component scanning doesn‚Äôt see it ‚Üí it does not exist

2Ô∏è‚É£ Code Snippet (correct usage)
@Component
public class EmailService {

    public void send(String msg) {
        System.out.println("Sending email: " + msg);
    }
}


Injection:

@Service
public class NotificationService {

    private final EmailService emailService;

    public NotificationService(EmailService emailService) {
        this.emailService = emailService;
    }
}


Bean name:

Default ‚Üí emailService

Class name camel-cased

Custom bean name
@Component("mailService")
public class EmailService { }


Injection now requires matching name if qualified.

3Ô∏è‚É£ Interview Perspective (expected answers)
Q1: What does @Component do?

‚úÖ Correct:

Marks a class as a Spring-managed component discovered via component scanning.

Q2: Is @Component mandatory to create a bean?

‚ùå No.

Beans can be created via:

@Bean

@Import

XML (legacy)

Q3: What is the default scope of a @Component?

‚úÖ singleton

Q4: Is @Component proxied?

‚ùå No ‚Äî unless combined with:

@Transactional

@Async

@Cacheable

AOP advice

Then Spring creates proxies conditionally.

4Ô∏è‚É£ Common Catches & Confusions (don‚Äôt ignore these)
‚ùå Confusion 1: @Component vs @Bean

People think they‚Äôre interchangeable. They‚Äôre not.

Feature	@Component	@Bean
Declared on	Class	Method
Creation	Spring	Developer
Scanning	Required	Not required
Best for	App classes	Third-party

Use the wrong one ‚Üí design smells.

‚ùå Confusion 2: Component scanning scope
@Component
public class UserService {}


But main class is in another package.

‚ùå Result: Bean not found
Spring didn‚Äôt fail ‚Äî you misconfigured scanning

‚ùå Confusion 3: Business logic in constructors
@Component
public class Foo {
    public Foo() {
        heavyOperation(); ‚ùå
    }
}


Spring creates beans at startup.
You just slowed boot time or caused failure.

Use @PostConstruct if needed ‚Äî sparingly.

‚ùå Confusion 4: Overusing @Component

Utility classes, DTOs, constants, mappers ‚Üí should NOT be components.

If it doesn‚Äôt:

Hold behavior
Need DI
Have lifecycle

Don‚Äôt make it a component.

5Ô∏è‚É£ Notes-Friendly Summary (copy this)
@Component
- Marks class as Spring-managed bean
- Discovered via component scanning
- Default scope = singleton
- No special behavior by itself



----------------------------------------------------------------------------

@Autowired
1Ô∏è‚É£ Theory (what @Autowired REALLY does)

@Autowired tells Spring:

‚ÄúInject a matching bean from the ApplicationContext here.‚Äù

That‚Äôs it.

Spring resolves the dependency using this order:

By type

By qualifier (if present)

By name (as a last resort)

If Spring can‚Äôt resolve exactly one bean ‚Üí runtime failure.

What @Autowired is NOT

‚ùå Not a bean creator

‚ùå Not a scanner

‚ùå Not magic

It only works after beans already exist.

2Ô∏è‚É£ Code Snippets (correct, modern usage)
‚úÖ Constructor Injection (BEST PRACTICE)
@Service
public class OrderService {

    private final PaymentService paymentService;

    @Autowired
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}


Why this is best:

Immutable dependency

Fails fast at startup

Easy to test

No reflection hacks

üö® Important (Spring 4.3+)

If a class has only one constructor, @Autowired is optional:

@Service
public class OrderService {

    private final PaymentService paymentService;

    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}


Senior-level code looks like this ‚òùÔ∏è
If you still add @Autowired here, it‚Äôs not wrong ‚Äî just noisy.

‚ùå Field Injection (DON‚ÄôT DO THIS)
@Service
public class OrderService {

    @Autowired
    private PaymentService paymentService; ‚ùå
}


Why this is bad:

Hidden dependency

Hard to test

Breaks immutability

Encourages sloppy design

This is tolerated only in:

Legacy code

Prototypes

Quick demos

‚ö†Ô∏è Setter Injection (rare but valid)
@Service
public class OrderService {

    private PaymentService paymentService;

    @Autowired
    public void setPaymentService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}


Use only when:

Dependency is optional

You truly need reconfiguration

3Ô∏è‚É£ Interview Perspective (expected answers)
Q1: How does @Autowired resolve dependencies?

‚úÖ Correct answer:

By type first, then by qualifier, then by bean name.

Q2: What happens if multiple beans of same type exist?
@Service
class A implements Engine {}

@Service
class B implements Engine {}

@Autowired
private Engine engine; ‚ùå


‚ùå NoUniqueBeanDefinitionException

Fix using:

@Qualifier("a")
private Engine engine;


or

@Primary
class A implements Engine {}

Q3: Is @Autowired mandatory?

‚ùå No.

Alternatives:

Constructor injection without annotation

@Inject (JSR-330)

XML (legacy)

Q4: When does injection happen?

‚úÖ After:

Bean instantiation

Before @PostConstruct

4Ô∏è‚É£ Common Catches & Confusions (VERY IMPORTANT)
‚ùå Confusion 1: Autowiring happens at compile time

Wrong.

It happens at runtime, during context initialization.

That‚Äôs why errors show up only when the app starts.

‚ùå Confusion 2: @Autowired works on non-beans
public class Utils {

    @Autowired
    private Service service; ‚ùå
}


This will never work.

Why?

Utils is not managed by Spring

No lifecycle

No injection

‚ùå Confusion 3: Optional dependencies
@Autowired
private PaymentService paymentService;


If missing ‚Üí startup failure

To make optional:

@Autowired(required = false)
private PaymentService paymentService;


OR better:

public OrderService(Optional<PaymentService> paymentService) { }

‚ùå Confusion 4: Circular dependencies
@Service
class A {
    @Autowired B b;
}

@Service
class B {
    @Autowired A a;
}


‚ùå Constructor injection ‚Üí FAILS
‚ùå Field injection ‚Üí works but is a design smell

Spring resolving it ‚â† good design.

5Ô∏è‚É£ Notes-Friendly Summary (write exactly)
@Autowired
- Injects existing Spring beans
- Resolves by type first
- Fails if no or multiple matches
- Best used on constructors
- Avoid field injection


-----------------------------------------------------------


@Qualifier
1Ô∏è‚É£ Theory (what @Qualifier REALLY does)

@Qualifier is used to disambiguate beans when multiple beans of the same type exist.

It tells Spring:

‚ÄúWhen injecting by type is ambiguous, use this specific bean.‚Äù

Key fact (non-negotiable):

@Qualifier works ONLY with @Autowired (or constructor injection)
It does NOT create beans. It does NOT change scanning.

Why @Qualifier exists

Spring‚Äôs default resolution:

By type
If multiple ‚Üí ‚ùå failure
@Qualifier narrows it down

Without it, Spring refuses to guess ‚Äî and that‚Äôs good.

2Ô∏è‚É£ Code Snippets (real scenarios)
Multiple beans of same type (problem)
@Component
public class PetrolEngine implements Engine {}

@Component
public class DieselEngine implements Engine {}


Injection:

@Autowired
private Engine engine; ‚ùå


Result:

NoUniqueBeanDefinitionException


Spring is right. You were vague.

Fix using @Qualifier
@Autowired
@Qualifier("petrolEngine")
private Engine engine;


Now Spring knows exactly what you want.

Constructor injection (BEST PRACTICE)
@Service
public class CarService {

    private final Engine engine;

    public CarService(@Qualifier("dieselEngine") Engine engine) {
        this.engine = engine;
    }
}


This is clean, explicit, and testable.

Custom qualifier value
@Component("fastEngine")
public class TurboEngine implements Engine {}

@Qualifier("fastEngine")
private Engine engine;


Bean name and qualifier must match.

3Ô∏è‚É£ Interview Perspective (expected answers)
Q1: Why do we need @Qualifier?

‚úÖ Correct:
To resolve ambiguity when multiple beans of the same type exist.

Q2: What happens without @Qualifier?
‚úÖ Correct:

Spring throws NoUniqueBeanDefinitionException.

Q3: Difference between @Qualifier and @Primary?
Aspect	@Qualifier	@Primary
Scope	Local (injection point)	Global
Explicit	Yes	Implicit
Overrides	No	Yes
Best for	Precise control	Default choice

Senior answer:

Use @Primary sparingly, @Qualifier explicitly.

Q4: Can @Qualifier be used on methods?

‚úÖ Yes:

@Bean
@Qualifier("secureEngine")
public Engine engine() {
    return new SecureEngine();
}

4Ô∏è‚É£ Common Catches & Confusions (THIS IS WHERE PEOPLE FAIL)
‚ùå Confusion 1: @Qualifier = bean name

Mostly true ‚Äî but not always.

By default ‚Üí matches bean name

Can also match custom qualifier annotations (advanced)

Don‚Äôt oversimplify in interviews.

‚ùå Confusion 2: Using @Qualifier without multiple beans
@Qualifier("engine")
@Autowired
private Engine engine;


This is noise if only one bean exists.

Using it everywhere = design paranoia.

‚ùå Confusion 3: Misspelling qualifier value
@Qualifier("dieselEngin") ‚ùå


Spring won‚Äôt warn you.
It will just fail at startup.

This is why string-based qualifiers are risky.

‚ùå Confusion 4: Mixing @Primary and @Qualifier
@Primary
@Component
class A implements Engine {}

@Qualifier("b")
@Component
class B implements Engine {}


Injection with @Qualifier("b")
üëâ Qualifier always wins

If you don‚Äôt know this, you don‚Äôt control injection.

5Ô∏è‚É£ Notes-Friendly Summary (write verbatim)
@Qualifier
- Resolves ambiguity between beans of same type
- Used with @Autowired / constructor injection
- Matches bean name by default
- Overrides @Primary at injection point

Key rule:
Spring injects by type first, qualifier second


-------------------------------------------------------------------

@Controller
1Ô∏è‚É£ Theory (what @Controller REALLY is)

@Controller marks a class as a Spring MVC controller.

Meaning:

This class handles HTTP requests and returns a view (HTML, JSP, Thymeleaf, etc.)

Key point most people miss:

@Controller is for server-side rendered applications, NOT REST APIs.

Technically:

@Controller = @Component + MVC semantics

Detected via component scanning

Works only when Spring MVC is enabled (via auto-config or @EnableWebMvc)

2Ô∏è‚É£ Code Snippets (correct usage)
Basic MVC Controller
@Controller
public class HomeController {

    @GetMapping("/home")
    public String home(Model model) {
        model.addAttribute("message", "Hello World");
        return "home"; // view name
    }
}


What happens:

/home ‚Üí controller method

Returns "home"

View resolver maps it to:

home.html (Thymeleaf)

home.jsp (JSP)

etc.

üëâ Return value is NOT JSON

With request parameters
@Controller
public class UserController {

    @GetMapping("/user")
    public String getUser(@RequestParam String name, Model model) {
        model.addAttribute("name", name);
        return "user";
    }
}

Redirects & forwards
return "redirect:/login";
return "forward:/internal";


These are MVC concepts, not REST concepts.

3Ô∏è‚É£ Interview Perspective (expected answers)
Q1: What is @Controller?

‚úÖ Correct:

A Spring MVC stereotype annotation used to define web controllers that return views.

Q2: Difference between @Controller and @RestController?
Aspect	@Controller	@RestController
Purpose	MVC	REST API
Return type	View name	Response body
JSON default	‚ùå No	‚úÖ Yes
@ResponseBody needed	Yes	No

Senior-level line:

@RestController = @Controller + @ResponseBody

Q3: Can @Controller return JSON?

‚úÖ Yes ‚Äî but only if you use @ResponseBody:

@GetMapping("/data")
@ResponseBody
public User getData() {
    return new User("John");
}


If you forget @ResponseBody ‚Üí Spring looks for a view named "User".

Q4: Is @Controller a Spring bean?

‚úÖ Yes. It‚Äôs detected via @ComponentScan.

4Ô∏è‚É£ Common Catches & Confusions (THIS IS IMPORTANT)
‚ùå Confusion 1: Using @Controller for REST APIs
@Controller
public class ApiController {
    @GetMapping("/users")
    public List<User> users() { ... } ‚ùå
}


Without @ResponseBody:

Spring tries to resolve a view called users

Result: 404 / ViewNotFound

Fix:

Use @RestController

OR add @ResponseBody

‚ùå Confusion 2: Returning objects without message converters

JSON conversion requires:

Jackson on classpath

MVC auto-configuration

Without it ‚Üí runtime failure.

‚ùå Confusion 3: Mixing MVC and REST in same controller
@Controller
public class MixedController {
    @GetMapping("/page") return "page";
    @GetMapping("/api") @ResponseBody return data;
}


This works ‚Äî but it‚Äôs bad design.

Separate:

MVC controllers

REST controllers

‚ùå Confusion 4: Controller ‚â† Business Logic

Putting logic here:

@Controller
public class OrderController {
    public String placeOrder() {
        // 200 lines of logic ‚ùå
    }
}


Controllers should:

Validate input

Delegate to services

Map responses

Anything else = architectural laziness.

5Ô∏è‚É£ Notes-Friendly Summary (copy exactly)
@Controller
- Handles HTTP requests
- Used in Spring MVC
- Returns view names by default
- Requires @ResponseBody for JSON
- Discovered via component scanning

