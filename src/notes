@SpringBootApplication

This is not magic. Itâ€™s a convenience annotation that bundles three critical annotations.
If you donâ€™t know what those three do individually, you donâ€™t understand Spring Boot.

@SpringBootApplication = meta-annotation

It is equivalent to writing all three below on your main class:

@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan

1. @SpringBootConfiguration

Same as @Configuration
Marks the class as a source of bean definitions
Tells Spring: â€œThis class can define beansâ€
ğŸ‘‰ Without this, Spring doesnâ€™t treat your app as a configuration source.

2. @EnableAutoConfiguration

Heart of Spring Boot
Automatically configures beans based on classpath
Example:
spring-webmvc present â†’ configures DispatcherServlet
spring-data-jpa present â†’ configures EntityManagerFactory
ğŸ‘‰ This is what eliminates XML and boilerplate.

3. @ComponentScan

Scans for:
@Component
@Service
@Repository
@Controller

Default scan package = package of the main class + subpackages
ğŸ‘‰ Misplacing your main class = app breaks silently.

@SpringBootApplication
public class MyApplication {

    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}

Q1: What does @SpringBootApplication do internally?
âœ… Correct answer:

It is a meta-annotation that combines @SpringBootConfiguration, @EnableAutoConfiguration, and @ComponentScan.

Q2: Can we replace @SpringBootApplication?
âœ… Yes. Use the three annotations manually.

Q3: How does Spring Boot know what to auto-configure?
âœ… Based on:

->Classpath dependencies
->spring.factories / AutoConfiguration.imports


->Conditional annotations like:

    ->@ConditionalOnClass
    ->@ConditionalOnMissingBean

Q4: Where should the main class be placed?
âœ… At the root package of the project.
Bad answer = â€œanywhereâ€

4ï¸âƒ£ Common Catches & Confusions (pay attention)
âŒ Confusion 1: â€œIt enables component scanning everywhereâ€
Wrong.
ğŸ‘‰ It scans only from the package of the main class downward.
com.example.app   â† main class here
  â”œâ”€â”€ controller  âœ… scanned
  â”œâ”€â”€ service     âœ… scanned
  â””â”€â”€ util        âœ… scanned

If your controller is in com.other.controller â†’ NOT scanned

âŒ Confusion 2: â€œSpring Boot auto-configures everythingâ€
Wrong.
It auto-configures only if:
Dependency exists
No conflicting bean already defined
Conditions pass

Example:
@Bean
public DataSource dataSource() { ... }

ğŸ‘‰ Auto-configured DataSource is disabled

âŒ Confusion 3: â€œ@SpringBootApplication is mandatoryâ€
Wrong.
You can build Spring apps without it.
It just saves typing and configuration.

âŒ Confusion 4: Multiple @SpringBootApplication
Terrible idea.
Only one main configuration class should exist.
Multiple = unpredictable component scanning.

5ï¸âƒ£ Notes-Friendly Summary (write this down)
@SpringBootApplication
= @SpringBootConfiguration
+ @EnableAutoConfiguration
+ @ComponentScan

Purpose:
- Entry point for Spring Boot app
- Enables auto-configuration
- Starts component scanning
- Defines configuration source

Default behavior:
- Scans current package + subpackages
- Auto-configures beans based on classpath

Key rule:
- Place main class at root package


------------------------------------------------------

@Configuration

1ï¸âƒ£ Theory (what it really does)

@Configuration marks a class as a Spring configuration class â€” a class that defines beans using @Bean methods.

But the important part most people miss:

@Configuration classes are CGLIB-proxied to enforce singleton behavior.

This is not optional trivia â€” this is the whole point.

What Spring does internally

When Spring sees:

@Configuration
public class AppConfig {
}


It:

Treats this class as a source of bean definitions
Creates a proxy subclass of it using CGLIB
Intercepts calls to @Bean methods

Why?
ğŸ‘‰ To ensure one and only one bean instance per container.

2ï¸âƒ£ Code Snippet (correct + revealing)
Basic usage
@Configuration
public class AppConfig {

    @Bean
    public UserService userService() {
        return new UserService();
    }
}


This registers userService as a Spring bean.

The part people mess up (VERY IMPORTANT)
@Configuration
public class AppConfig {

    @Bean
    public Engine engine() {
        return new Engine();
    }

    @Bean
    public Car car() {
        return new Car(engine());
    }
}

What actually happens?

engine() is called once

Same Engine instance is injected into Car

Why?
Because Spring intercepts the method call using a proxy.

3ï¸âƒ£ Interview Perspective (expected answers)
Q1: Difference between @Configuration and @Component?

âœ… Correct answer:

Feature	@Configuration	@Component
Bean methods	Yes (@Bean)	Yes
Proxying	Yes (CGLIB)	âŒ No
Singleton guarantee	Yes	âŒ No
Intended use	Config class	Generic bean

If they ask â€œwhy proxying?â€
Say: To preserve singleton semantics of @Bean methods

Q2: What happens if you remove @Configuration?
@Component
public class AppConfig {


ğŸ‘‰ Each call to engine() creates a new instance
ğŸ‘‰ You silently break singleton behavior

This is a classic senior-level trap question.

Q3: Is @Configuration mandatory?

âŒ No.

But without it:

No proxying

No inter-bean lifecycle management

4ï¸âƒ£ Common Catches & Confusions (read twice)
âŒ Confusion 1: "@Configuration is same as @Component"

Wrong.

@Configuration = specialized @Component
with proxy-based behavior.

âŒ Confusion 2: Calling @Bean methods directly is safe

Only safe inside a @Configuration class.

Outside:

new AppConfig().engine(); // NOT managed by Spring


ğŸ‘‰ Completely bypasses Spring.

âŒ Confusion 3: Final classes or methods
@Configuration
public final class AppConfig { âŒ }

or

@Bean
public final Engine engine() { âŒ }


âŒ CGLIB cannot proxy final
ğŸ‘‰ Spring will either fail or downgrade behavior

âŒ Confusion 4: Performance concerns

Yes, proxying has overhead â€” but:

Happens at startup

Negligible vs application lifecycle

If someone avoids @Configuration for â€œperformanceâ€, they donâ€™t know what theyâ€™re doing.

5ï¸âƒ£ Notes-Friendly Summary (copy-paste)
@Configuration
- Marks class as source of bean definitions
- Uses CGLIB proxy
- Ensures singleton behavior of @Bean methods
- Intercepts inter-bean method calls

Key point:
@Configuration â‰  @Component

Without @Configuration:
- No proxying
- New instance per @Bean call

-------------------------------------------------------------

@Bean
1ï¸âƒ£ Theory (what @Bean ACTUALLY does)

@Bean tells Spring:

â€œThe object returned by this method should be managed by the Spring container.â€

Thatâ€™s it.
No magic. No scanning. Explicit bean registration.

Key truth (write this down)

@Component â†’ implicit bean creation (via scanning)

@Bean â†’ explicit bean creation (via method call)

Spring does not create the object.
YOU create it, Spring just manages the lifecycle.

Where @Bean is allowed

@Bean must be inside:

    @Configuration (preferred)
    or any @Component (works, but with consequences)

2ï¸âƒ£ Code Snippets (correct + traps)
Basic usage

@Configuration
public class AppConfig {

    @Bean
    public EmailService emailService() {
        return new EmailService();
    }
}


Result:

    Bean name â†’ emailService
    Scope â†’ singleton (default)
    Managed by Spring

Dependency injection via method calls (IMPORTANT)
@Configuration
public class AppConfig {

    @Bean
    public Engine engine() {
        return new Engine();
    }

    @Bean
    public Car car() {
        return new Car(engine());
    }
}


ğŸ‘‰ Even though engine() is called inside car()
ğŸ‘‰ Same singleton instance is used

WHY?
Because @Configuration uses CGLIB proxying (you learned this already).

âŒ Classic mistake: using @Bean inside @Component
@Component
public class AppConfig {

    @Bean
    public Engine engine() {
        return new Engine();
    }

    @Bean
    public Car car() {
        return new Car(engine());
    }
}


âŒ Result:

engine() called twice
Two different Engine objects
Singleton contract broken silently
This is a real production bug, not theory.

3ï¸âƒ£ Interview Perspective (expected answers)
Q1: Difference between @Bean and @Component?

âœ… Correct answer:

Aspect	@Bean	@Component
Registration	Explicit	Implicit
Location	Method	Class
Use case	Third-party / fine control	App-level components
Creation	Developer creates object	Spring creates object

Q2: When should you prefer @Bean?

âœ… Use @Bean when:

You donâ€™t own the class (third-party libs)

You need custom construction logic

Object creation is conditional or complex

Example:

@Bean
public ObjectMapper objectMapper() {
    return JsonMapper.builder()
        .enable(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)
        .build();
}

Q3: What is the default scope of @Bean?

âœ… singleton

If they ask how to change it:

@Bean
@Scope("prototype")
public Engine engine() {
    return new Engine();
}

Q4: How does Spring resolve dependencies for @Bean methods?

Answer:

By method calls (inside @Configuration)

Or by method parameters (preferred)

@Bean
public Car car(Engine engine) {
    return new Car(engine);
}


This is cleaner and safer.

4ï¸âƒ£ Common Catches & Confusions (THIS IS GOLD)
âŒ Confusion 1: Bean name confusion
@Bean
public Engine myEngine() { ... }


Bean name = myEngine

If you do:

@Bean(name = "engine")
public Engine myEngine() { ... }


Bean name = engine

Injection will fail if names mismatch.

âŒ Confusion 2: Multiple beans of same type
@Bean
public Engine petrolEngine() {}

@Bean
public Engine dieselEngine() {}


âŒ Autowiring by type fails.

Fix using:

@Qualifier

or @Primary

âŒ Confusion 3: Calling @Bean method manually
Engine e = appConfig.engine(); âŒ


This bypasses Spring unless proxied.
Outside container = unmanaged object.

âŒ Confusion 4: @Bean â‰  lazy by default

@Bean methods are eagerly executed at startup.

To make lazy:

@Bean
@Lazy
public Engine engine() { ... }

5ï¸âƒ£ Notes-Friendly Summary (copy exactly)
@Bean
- Explicitly registers a bean
- Method return value becomes Spring-managed
- Default scope = singleton
- Bean name = method name
- Best used inside @Configuration

Key rule:
@Bean inside @Component breaks singleton guarantees

Brutally Honest Reality Check

If you:

Put @Bean inside random @Components

Call @Bean methods manually

Donâ€™t understand proxying

Then your app works by accident, not by design.

Senior Spring devs avoid accidental behavior.


-------------------------------------------------------------

@Component
1ï¸âƒ£ Theory (what @Component really means)

@Component tells Spring:

â€œThis class is a candidate for component scanning and should be managed as a bean.â€

Thatâ€™s it.

No lifecycle magic.
No special behavior.
No auto-transaction.
No proxying by default.

Itâ€™s just a generic Spring-managed bean.

How @Component works internally

Detected only via @ComponentScan

Registered as a bean in the ApplicationContext

Instantiated by Spring

Dependency injection happens afterward

If component scanning doesnâ€™t see it â†’ it does not exist

2ï¸âƒ£ Code Snippet (correct usage)
@Component
public class EmailService {

    public void send(String msg) {
        System.out.println("Sending email: " + msg);
    }
}


Injection:

@Service
public class NotificationService {

    private final EmailService emailService;

    public NotificationService(EmailService emailService) {
        this.emailService = emailService;
    }
}


Bean name:

Default â†’ emailService

Class name camel-cased

Custom bean name
@Component("mailService")
public class EmailService { }


Injection now requires matching name if qualified.

3ï¸âƒ£ Interview Perspective (expected answers)
Q1: What does @Component do?

âœ… Correct:

Marks a class as a Spring-managed component discovered via component scanning.

Q2: Is @Component mandatory to create a bean?

âŒ No.

Beans can be created via:

@Bean

@Import

XML (legacy)

Q3: What is the default scope of a @Component?

âœ… singleton

Q4: Is @Component proxied?

âŒ No â€” unless combined with:

@Transactional

@Async

@Cacheable

AOP advice

Then Spring creates proxies conditionally.

4ï¸âƒ£ Common Catches & Confusions (donâ€™t ignore these)
âŒ Confusion 1: @Component vs @Bean

People think theyâ€™re interchangeable. Theyâ€™re not.

Feature	@Component	@Bean
Declared on	Class	Method
Creation	Spring	Developer
Scanning	Required	Not required
Best for	App classes	Third-party

Use the wrong one â†’ design smells.

âŒ Confusion 2: Component scanning scope
@Component
public class UserService {}


But main class is in another package.

âŒ Result: Bean not found
Spring didnâ€™t fail â€” you misconfigured scanning

âŒ Confusion 3: Business logic in constructors
@Component
public class Foo {
    public Foo() {
        heavyOperation(); âŒ
    }
}


Spring creates beans at startup.
You just slowed boot time or caused failure.

Use @PostConstruct if needed â€” sparingly.

âŒ Confusion 4: Overusing @Component

Utility classes, DTOs, constants, mappers â†’ should NOT be components.

If it doesnâ€™t:

Hold behavior
Need DI
Have lifecycle

Donâ€™t make it a component.

5ï¸âƒ£ Notes-Friendly Summary (copy this)
@Component
- Marks class as Spring-managed bean
- Discovered via component scanning
- Default scope = singleton
- No special behavior by itself
